<!doctype html>
<html lang="pt-BR">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Piper TTS (pt_BR-edresson-low) ‚Äî Offline no navegador + MP3</title>
<style>
  :root{font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  body{margin:0;padding:24px;background:#0b1020;color:#e7ecff}
  .card{max-width:880px;margin:0 auto;background:#121936;border-radius:16px;padding:24px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
  h1{margin:0 0 12px}
  label{display:block;margin:12px 0 6px;opacity:.9}
  textarea{width:100%;min-height:140px;border-radius:12px;border:1px solid #2a335c;background:#0f1630;color:#fff;padding:12px;font-size:16px}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  select,input[type="number"],input[type="range"]{width:100%;border-radius:10px;border:1px solid #2a335c;background:#0f1630;color:#fff;padding:10px;font-size:15px}
  .btns{display:flex;gap:12px;margin-top:16px;flex-wrap:wrap}
  button{border:0;border-radius:12px;padding:12px 16px;font-weight:600;cursor:pointer;background:#4f6bff;color:#fff}
  button.secondary{background:#28315a}
  .note{opacity:.8;font-size:13px;margin-top:10px}
  .log{font-family:ui-monospace,Menlo,Consolas,monospace;font-size:12px;background:#0f1630;border:1px solid #2a335c;border-radius:12px;padding:10px;white-space:pre-wrap;max-height:220px;overflow:auto;margin-top:12px}
  audio{width:100%;margin-top:12px}
</style>

<div class="card">
  <h1>Piper TTS (pt_BR-edresson-low) ‚Äî MP3 offline</h1>

  <label for="text">Texto</label>
  <textarea id="text">Ol√°! Este √°udio foi gerado 100% no navegador usando Piper TTS e convertido para MP3 no pr√≥prio aparelho.</textarea>

  <div class="grid">
    <div>
      <label for="voice">Voz</label>
      <select id="voice">
        <option value="pt_BR-edresson-low" selected>pt_BR-edresson-low</option>
      </select>
    </div>
    <div>
      <label for="rate">Velocidade (0.5‚Äì2.0): <span id="rateVal">1.0</span></label>
      <input id="rate" type="range" min="0.5" max="2" step="0.05" value="1">
    </div>
  </div>

  <div class="grid">
    <div>
      <label for="volume">Volume (0‚Äì1): <span id="volVal">1.0</span></label>
      <input id="volume" type="range" min="0" max="1" step="0.05" value="1">
    </div>
    <div>
      <label for="format">Formato para baixar</label>
      <select id="format">
        <option value="mp3" selected>MP3 (compacto)</option>
        <option value="wav">WAV (sem perda, maior)</option>
      </select>
    </div>
  </div>

  <div class="btns">
    <button id="btnSpeak">‚ñ∂Ô∏è Reproduzir</button>
    <button id="btnStop" class="secondary">‚èπÔ∏è Parar</button>
    <button id="btnDownload" class="secondary">‚¨áÔ∏è Baixar</button>
    <button id="btnPreload" class="secondary">‚¨áÔ∏è Pr√©-carregar modelo</button>
    <button id="btnClear" class="secondary">üßπ Limpar modelos salvos</button>
  </div>

  <audio id="player" controls></audio>

  <div class="note">
    Primeira execu√ß√£o baixa o modelo (pode demorar um pouco). Depois fica salvo localmente.
    Se sua rede bloquear, hospede os arquivos do modelo no seu pr√≥prio reposit√≥rio e troque a base de download no c√≥digo (procure por <code>CUSTOM_MODEL_BASE</code>).
  </div>

  <div id="log" class="log"></div>
</div>

<!-- LameJS para MP3 (MIT) -->
<script src="https://cdn.jsdelivr.net/gh/zhuker/lamejs@master/lame.all.js"></script>

<!-- Import ESM da lib de Piper para Web; usa ONNX Runtime Web por baixo -->
<script type="module">
  // Dantas: se quiser for√ßar baixar os arquivos do modelo do seu pr√≥prio GitHub Pages,
  // defina CUSTOM_MODEL_BASE para o caminho onde voc√™ colocou:
  //   pt_BR/pt_BR-edresson-low.onnx
  //   pt_BR/pt_BR-edresson-low.onnx.json
  // Ex.: 'https://seu-usuario.github.io/seu-repo/models/'
  const CUSTOM_MODEL_BASE = ""; // deixe vazio para usar a CDN padr√£o da lib

  const logEl = document.getElementById('log');
  const player = document.getElementById('player');
  const rateInp = document.getElementById('rate');
  const volInp = document.getElementById('volume');
  const rateVal = document.getElementById('rateVal');
  const volVal = document.getElementById('volVal');
  const voiceSel = document.getElementById('voice');
  const formatSel = document.getElementById('format');
  const textArea = document.getElementById('text');

  const log = (m) => { logEl.textContent += m + "\n"; logEl.scrollTop = logEl.scrollHeight; };
  rateInp.addEventListener('input', ()=> rateVal.textContent = rateInp.value);
  volInp.addEventListener('input', ()=> volVal.textContent = volInp.value);

  // Import da lib Piper TTS para browser (Mintplex Labs)
  // Dica: se der CORS/ESM, troque para esm.sh abaixo
  let tts;
  try {
    tts = await import('https://cdn.jsdelivr.net/npm/@mintplex-labs/piper-tts-web@latest/dist/index.min.js');
  } catch (e) {
    // fallback via esm.sh
    tts = await import('https://esm.sh/@mintplex-labs/piper-tts-web@latest');
  }

  // Config opcional: base personalizada para modelos/wasm
  if (CUSTOM_MODEL_BASE) {
    // Algumas vers√µes da lib exp√µem configure(); mantemos cheque defensivo
    if (tts.configure) {
      tts.configure({
        // Base onde ficar√£o os .onnx e .onnx.json (ex.: seu GH Pages)
        modelBaseUrl: CUSTOM_MODEL_BASE
      });
    }
  }

  // Estado
  let lastWavBlob = null;
  let currentAudio = null;

  async function ensureDownloaded(voiceId){
    log(`Checando modelo "${voiceId}"...`);
    const stored = (await tts.stored?.()) || [];
    if (!stored.includes(voiceId)) {
      log(`Baixando modelo "${voiceId}" (primeira vez pode demorar)...`);
      await tts.download(voiceId, (p) => {
        if (!p || !p.total) return;
        const pct = Math.round((p.loaded*100)/p.total);
        log(`‚Üí ${p.url ?? 'arquivo'}: ${pct}%`);
      });
      log(`Modelo "${voiceId}" salvo offline.`);
    } else {
      log(`Modelo j√° est√° salvo localmente.`);
    }
  }

  function blobToArrayBuffer(blob){ return blob.arrayBuffer(); }

  function parseWavToPCM16(wavBuffer){
    // Leitor simples do cabe√ßalho WAV PCM 16-bit mono/stereo
    const dv = new DataView(wavBuffer);
    const channels = dv.getUint16(22, true);
    const sampleRate = dv.getUint32(24, true);
    const bitsPerSample = dv.getUint16(34, true);
    // Localiza "data"
    let pos = 12;
    while (pos < dv.byteLength){
      const id = dv.getUint32(pos, false); // big endian 'data'
      const size = dv.getUint32(pos+4, true);
      if (id === 0x64617461) { // "data"
        const pcm = new Int16Array(wavBuffer, pos+8, size/2);
        return { pcm, sampleRate, channels, bitsPerSample };
      }
      pos += 8 + size;
    }
    throw new Error("Chunk 'data' n√£o encontrado no WAV.");
  }

  function encodeMp3FromPCM({ pcm, sampleRate, channels }){
    // Se vier stereo, interleavado; lamejs espera por canal
    // Simplifica√ß√£o: se stereo, converte para mono fazendo m√©dia
    let mono = pcm;
    if (channels === 2){
      const leftRight = new Int16Array(pcm.length/2);
      for (let i=0, j=0; i<pcm.length; i+=2, j++){
        leftRight[j] = (pcm[i] + pcm[i+1]) >> 1;
      }
      mono = leftRight;
    }
    const kbps = 128; // taxa padr√£o
    const mp3enc = new lamejs.Mp3Encoder(1, sampleRate, kbps);
    const samplesPerFrame = 1152;
    let mp3Data = [];
    for (let i=0; i<mono.length; i += samplesPerFrame){
      const chunk = mono.subarray(i, i+samplesPerFrame);
      const mp3buf = mp3enc.encodeBuffer(chunk);
      if (mp3buf.length) mp3Data.push(new Int8Array(mp3buf));
    }
    const end = mp3enc.flush();
    if (end.length) mp3Data.push(new Int8Array(end));
    // Concatena
    let size = 0; mp3Data.forEach(b => size += b.length);
    const out = new Uint8Array(size);
    let offset = 0; mp3Data.forEach(b => { out.set(b, offset); offset += b.length; });
    return new Blob([out], { type: 'audio/mpeg' });
  }

  function downloadBlob(blob, filename){
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = filename;
    document.body.appendChild(a); a.click();
    URL.revokeObjectURL(url); a.remove();
  }

  async function synthesize(){
    const text = textArea.value.trim();
    if (!text) { log("Digite um texto."); return; }
    const voiceId = voiceSel.value;
    await ensureDownloaded(voiceId);

    log("Sintetizando com Piper...");
    const wavBlob = await tts.predict({
      text,
      voiceId,
      // Par√¢metros expostos pela lib: rate (speed) e volume
      // Alguns modelos ignoram parte destes params
      rate: parseFloat(rateInp.value),    // 1 = normal
      volume: parseFloat(volInp.value)    // 1 = 100%
    }, (p)=>{ if (p && p.progress) log(`Progresso: ${Math.round(p.progress*100)}%`); });

    lastWavBlob = wavBlob;
    player.src = URL.createObjectURL(wavBlob);
    player.play().catch(()=>{ /* usu√°rio precisa clicar */ });
    log("Pronto! √Åudio gerado.");
  }

  document.getElementById('btnSpeak').addEventListener('click', synthesize);

  document.getElementById('btnStop').addEventListener('click', ()=>{
    try { player.pause(); player.currentTime = 0; } catch(e){}
  });

  document.getElementById('btnPreload').addEventListener('click', async ()=>{
    await ensureDownloaded(voiceSel.value);
  });

  document.getElementById('btnClear').addEventListener('click', async ()=>{
    if (confirm("Apagar modelos salvos localmente?")) {
      await tts.flush?.();
      log("Modelos removidos do armazenamento local.");
    }
  });

  document.getElementById('btnDownload').addEventListener('click', async ()=>{
    if (!lastWavBlob){
      log("Gere um √°udio primeiro.");
      return;
    }
    const fmt = formatSel.value;
    if (fmt === 'wav'){
      downloadBlob(lastWavBlob, 'piper.wav');
      return;
    }
    // WAV -> MP3 (cliente)
    log("Convertendo WAV ‚Üí MP3...");
    const wavAb = await blobToArrayBuffer(lastWavBlob);
    const { pcm, sampleRate, channels } = parseWavToPCM16(wavAb);
    const mp3Blob = encodeMp3FromPCM({ pcm, sampleRate, channels });
    downloadBlob(mp3Blob, 'piper.mp3');
    log("MP3 baixado.");
  });

  // Dica: liste vozes dispon√≠veis (√∫til para trocar voz futuramente)
  try {
    const voices = await (tts.voices?.() || []);
    if (voices.length) log(`Vozes dispon√≠veis pela lib: ${voices.slice(0,8).join(', ')}${voices.length>8?'‚Ä¶':''}`);
  } catch(_) {}
</script>
</html>
