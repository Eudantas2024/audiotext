<!doctype html>
<html lang="pt-BR">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Piper TTS ‚Äî pt_BR-edresson-low (MP3 offline)</title>
<style>
  :root{font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  body{margin:0;padding:24px;background:#0b1020;color:#e7ecff}
  .card{max-width:880px;margin:0 auto;background:#121936;border-radius:16px;padding:24px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
  h1{margin:0 0 12px}
  label{display:block;margin:12px 0 6px;opacity:.9}
  textarea{width:100%;min-height:140px;border-radius:12px;border:1px solid #2a335c;background:#0f1630;color:#fff;padding:12px;font-size:16px}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  select,input[type="range"]{width:100%;border-radius:10px;border:1px solid #2a335c;background:#0f1630;color:#fff;padding:10px;font-size:15px}
  .btns{display:flex;gap:12px;margin-top:16px;flex-wrap:wrap}
  button{border:0;border-radius:12px;padding:12px 16px;font-weight:600;cursor:pointer;background:#4f6bff;color:#fff}
  button.secondary{background:#28315a}
  .note{opacity:.8;font-size:13px;margin-top:10px}
  .log{font-family:ui-monospace,Menlo,Consolas,monospace;font-size:12px;background:#0f1630;border:1px solid #2a335c;border-radius:12px;padding:10px;white-space:pre-wrap;max-height:260px;overflow:auto;margin-top:12px}
  audio{width:100%;margin-top:12px}
</style>

<div class="card">
  <h1>Piper TTS ‚Äî pt_BR-edresson-low (MP3 offline)</h1>

  <label for="text">Texto</label>
  <textarea id="text">Ol√°! Este √°udio foi gerado 100% no navegador usando Piper TTS e convertido para MP3 no pr√≥prio aparelho.</textarea>

  <div class="grid">
    <div>
      <label for="rate">Velocidade (0.5‚Äì2.0): <span id="rateVal">1.0</span></label>
      <input id="rate" type="range" min="0.5" max="2" step="0.05" value="1">
    </div>
    <div>
      <label for="volume">Volume (0‚Äì1): <span id="volVal">1.0</span></label>
      <input id="volume" type="range" min="0" max="1" step="0.05" value="1">
    </div>
  </div>

  <div class="grid">
    <div>
      <label for="format">Formato do download</label>
      <select id="format">
        <option value="mp3" selected>MP3 (compacto)</option>
        <option value="wav">WAV (sem perda, maior)</option>
      </select>
    </div>
    <div class="note" style="align-self:end">
      1¬™ vez: use <b>Pr√©-carregar modelo</b>. Depois clique em <b>Reproduzir</b>.
    </div>
  </div>

  <div class="btns">
    <button id="btnPreload" class="secondary">‚¨áÔ∏è Pr√©-carregar modelo</button>
    <button id="btnSpeak">‚ñ∂Ô∏è Reproduzir</button>
    <button id="btnStop" class="secondary">‚èπÔ∏è Parar</button>
    <button id="btnDownload" class="secondary">‚¨áÔ∏è Baixar</button>
    <button id="btnClear" class="secondary">üßπ Limpar modelos</button>
    <button id="btnDiag" class="secondary">üß™ Diagn√≥stico</button>
  </div>

  <audio id="player" controls></audio>
  <div id="log" class="log"></div>

  <div class="note">
    Se aparecer erro de import ou download, confira a URL em <code>CUSTOM_MODEL_BASE</code> e se os arquivos
    <code>pt_BR-edresson-low.onnx</code> e <code>.onnx.json</code> est√£o publicados no seu GitHub Pages.
  </div>
</div>

<!-- LameJS para MP3 (MIT) -->
<script src="https://cdn.jsdelivr.net/gh/zhuker/lamejs@master/lame.all.js"></script>

<script type="module">
  // üîß COLOQUE AQUI a pasta onde voc√™ publicou os arquivos do modelo no seu GitHub Pages:
  // Ex.: 'https://seu-usuario.github.io/seu-repo/models/pt_BR/'
  const CUSTOM_MODEL_BASE = 'https://SEU-USUARIO.github.io/SEU-REPO/models/pt_BR/';

  const VOICE_ID = 'pt_BR-edresson-low';
  const logEl = document.getElementById('log');
  const player = document.getElementById('player');
  const rateInp = document.getElementById('rate');
  const volInp = document.getElementById('volume');
  const rateVal = document.getElementById('rateVal');
  const volVal = document.getElementById('volVal');
  const textArea = document.getElementById('text');
  const formatSel = document.getElementById('format');

  const log = (m)=>{ logEl.textContent += m + "\n"; logEl.scrollTop = logEl.scrollHeight; };
  const ok  = (m)=> log('‚úÖ ' + m);
  const err = (m)=> log('‚ùå ' + m);

  rateInp.addEventListener('input', ()=> rateVal.textContent = rateInp.value);
  volInp.addEventListener('input', ()=> volVal.textContent = volInp.value);

  // ==== Import robusto da lib Piper TTS para Web ====
  let tts;
  try {
    // 1) esm.sh tende a servir ESM sempre
    tts = await import('https://esm.sh/@mintplex-labs/piper-tts-web@latest');
    ok('Import via esm.sh OK');
  } catch (e1) {
    err('Falhou import via esm.sh: ' + e1.message);
    try {
      // 2) fallback jsDelivr
      tts = await import('https://cdn.jsdelivr.net/npm/@mintplex-labs/piper-tts-web@latest/dist/index.min.js');
      ok('Import via jsDelivr OK');
    } catch (e2) {
      err('Falhou import via jsDelivr: ' + e2.message);
    }
  }

  // algumas CDNs exportam em tts.default
  const api = (tts && (tts.default || tts)) || {};
  const fn = (name)=> api[name] || (api.core && api.core[name]);
  const download = fn('download');
  const predict  = fn('predict');
  const voices   = fn('voices');
  const stored   = fn('stored');
  const flush    = fn('flush');
  const configure= fn('configure');

  if (configure && CUSTOM_MODEL_BASE) {
    try {
      configure({ modelBaseUrl: CUSTOM_MODEL_BASE });
      ok('Base de modelos configurada: ' + CUSTOM_MODEL_BASE);
    } catch(e){ err('Falha ao configurar base de modelos: ' + e.message); }
  } else if (CUSTOM_MODEL_BASE) {
    log('‚ÑπÔ∏è Sua vers√£o da lib pode n√£o expor configure(). Mesmo assim, os downloads tentar√£o usar caminhos padr√£o. Se falhar, verifique os arquivos.');
  }

  async function ensureDownloaded(){
    if (!download) { err('API download() n√£o dispon√≠vel; a lib n√£o carregou corretamente.'); return; }
    log(`Checando modelo "${VOICE_ID}"...`);
    try {
      const keep = (await stored?.()) || [];
      if (keep.includes(VOICE_ID)) { ok('Modelo j√° existe localmente.'); return; }
    } catch(_) {}

    log('Baixando modelo (pode demorar na 1¬™ vez)‚Ä¶');
    try {
      await download(VOICE_ID, (p)=>{
        if (!p || !p.total) return;
        const pct = Math.round((p.loaded*100)/p.total);
        log(`‚Üí ${p.url || 'arquivo'}: ${pct}%`);
      });
      ok('Modelo salvo offline.');
    } catch(e) {
      err('Erro ao baixar modelo. Verifique CUSTOM_MODEL_BASE e os arquivos .onnx/.json. ' + e.message);
    }
  }

  let lastWavBlob = null;

  async function synthesize(){
    if (!predict) { err('API predict() n√£o dispon√≠vel; a lib n√£o carregou corretamente.'); return; }
    const text = textArea.value.trim();
    if (!text) { log('Digite um texto.'); return; }
    await ensureDownloaded();
    log('Sintetizando (Piper)‚Ä¶');
    try {
      const wavBlob = await predict({
        text,
        voiceId: VOICE_ID,
        rate: parseFloat(rateInp.value),
        volume: parseFloat(volInp.value)
      }, (p)=>{ if (p && p.progress) log(`Progresso: ${Math.round(p.progress*100)}%`); });
      lastWavBlob = wavBlob;
      player.src = URL.createObjectURL(wavBlob);
      player.play().catch(()=>{ /* gesture pode ser necess√°rio */ });
      ok('√Åudio pronto.');
    } catch(e) {
      err('Erro na s√≠ntese: ' + e.message);
    }
  }

  function parseWavToPCM16(wavBuffer){
    const dv = new DataView(wavBuffer);
    if (dv.getUint32(0, false) !== 0x52494646) throw new Error('N√£o √© um RIFF WAV');
    const channels = dv.getUint16(22, true);
    const sampleRate = dv.getUint32(24, true);
    const bitsPerSample = dv.getUint16(34, true);
    let pos = 12;
    while (pos < dv.byteLength){
      const id = dv.getUint32(pos, false);
      const size = dv.getUint32(pos+4, true);
      if (id === 0x64617461) { // 'data'
        const pcm = new Int16Array(wavBuffer, pos+8, size/2);
        return { pcm, sampleRate, channels, bitsPerSample };
      }
      pos += 8 + size;
    }
    throw new Error("Chunk 'data' n√£o encontrado no WAV.");
  }

  function encodeMp3FromPCM({ pcm, sampleRate, channels }){
    let mono = pcm;
    if (channels === 2){
      const m = new Int16Array(pcm.length/2);
      for (let i=0, j=0; i<pcm.length; i+=2, j++) m[j] = (pcm[i]+pcm[i+1])>>1;
      mono = m;
    }
    const kbps = 128;
    const enc = new lamejs.Mp3Encoder(1, sampleRate, kbps);
    const frame = 1152;
    const out = [];
    for (let i=0;i<mono.length;i+=frame){
      const chunk = mono.subarray(i, i+frame);
      const buf = enc.encodeBuffer(chunk);
      if (buf.length) out.push(new Int8Array(buf));
    }
    const end = enc.flush(); if (end.length) out.push(new Int8Array(end));
    let total=0; out.forEach(b=> total+=b.length);
    const u8 = new Uint8Array(total);
    let off=0; out.forEach(b=>{ u8.set(b, off); off+=b.length; });
    return new Blob([u8], { type:'audio/mpeg' });
  }

  function downloadBlob(blob, filename){
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = filename;
    document.body.appendChild(a); a.click();
    URL.revokeObjectURL(url); a.remove();
  }

  document.getElementById('btnPreload').addEventListener('click', ensureDownloaded);
  document.getElementById('btnSpeak').addEventListener('click', synthesize);
  document.getElementById('btnStop').addEventListener('click', ()=>{ try{ player.pause(); player.currentTime=0; }catch(_){} });
  document.getElementById('btnClear').addEventListener('click', async ()=>{
    try { await flush?.(); ok('Modelos removidos do armazenamento local.'); } catch(e){ err('Falha ao limpar: '+e.message); }
  });

  document.getElementById('btnDownload').addEventListener('click', async ()=>{
    if (!lastWavBlob){ log('Gere um √°udio primeiro.'); return; }
    const fmt = formatSel.value;
    if (fmt === 'wav'){ downloadBlob(lastWavBlob, 'piper.wav'); ok('WAV baixado.'); return; }
    try {
      log('Convertendo WAV ‚Üí MP3‚Ä¶');
      const ab = await lastWavBlob.arrayBuffer();
      const { pcm, sampleRate, channels } = parseWavToPCM16(ab);
      const mp3 = encodeMp3FromPCM({ pcm, sampleRate, channels });
      downloadBlob(mp3, 'piper.mp3');
      ok('MP3 baixado.');
    } catch(e){ err('Falha na convers√£o para MP3: ' + e.message); }
  });

  document.getElementById('btnDiag').addEventListener('click', async ()=>{
    log('=== Diagn√≥stico r√°pido ===');
    try { ok('HTTPS: ' + (location.protocol === 'https:' ? 'sim' : 'n√£o')); } catch(_){}
    try { ok('WASM: ' + (typeof WebAssembly !== 'undefined')); } catch(_){}
    try { ok('AudioContext: ' + (window.AudioContext ? 'sim' : 'n√£o')); } catch(_){}
    try {
      const r = await fetch((CUSTOM_MODEL_BASE || '.') + 'pt_BR-edresson-low.onnx', { method:'HEAD', cache:'no-store' });
      log('HEAD .onnx: ' + r.status + ' ' + r.statusText);
    } catch(e){ err('Falha HEAD .onnx: ' + e.message); }
    try {
      const r = await fetch((CUSTOM_MODEL_BASE || '.') + 'pt_BR-edresson-low.onnx.json', { method:'HEAD', cache:'no-store' });
      log('HEAD .json: ' + r.status + ' ' + r.statusText);
    } catch(e){ err('Falha HEAD .json: ' + e.message); }
  });

  // Dica: listar vozes conhecidas pela lib (opcional)
  try {
    const v = await voices?.();
    if (v?.length) log('Vozes dispon√≠veis na lib: ' + v.slice(0,8).join(', ') + (v.length>8?'‚Ä¶':''));
  } catch(_){}
</script>
</html>
